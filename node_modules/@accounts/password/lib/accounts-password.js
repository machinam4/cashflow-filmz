"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var two_factor_1 = require("@accounts/two-factor");
var server_1 = require("@accounts/server");
var utils_1 = require("./utils");
var errors_1 = require("./errors");
var defaultOptions = {
    // 3 days - 3 * 24 * 60 * 60 * 1000
    verifyEmailTokenExpiration: 259200000,
    // 3 days - 3 * 24 * 60 * 60 * 1000
    passwordResetTokenExpiration: 259200000,
    // 30 days - 30 * 24 * 60 * 60 * 1000
    passwordEnrollTokenExpiration: 2592000000,
    notifyUserAfterPasswordChanged: true,
    returnTokensAfterResetPassword: false,
    invalidateAllSessionsAfterPasswordReset: true,
    invalidateAllSessionsAfterPasswordChanged: false,
    removeAllResetPasswordTokensAfterPasswordChanged: true,
    errors: errors_1.errors,
    sendVerificationEmailAfterSignup: false,
    validateEmail: function (email) {
        return !lodash_1.isEmpty(lodash_1.trim(email)) && utils_1.isEmail(email);
    },
    validatePassword: function (password) {
        return !lodash_1.isEmpty(password);
    },
    validateUsername: function (username) {
        var usernameRegex = /^[a-zA-Z][a-zA-Z0-9]*$/;
        var isValid = username && !lodash_1.isEmpty(lodash_1.trim(username)) && usernameRegex.test(username);
        return Boolean(isValid);
    },
    hashPassword: utils_1.bcryptPassword,
    verifyPassword: utils_1.verifyPassword,
};
var AccountsPassword = /** @class */ (function () {
    function AccountsPassword(options) {
        if (options === void 0) { options = {}; }
        this.serviceName = 'password';
        this.options = tslib_1.__assign(tslib_1.__assign({}, defaultOptions), options);
        this.twoFactor = new two_factor_1.TwoFactor(options.twoFactor);
    }
    AccountsPassword.prototype.setStore = function (store) {
        this.db = store;
        this.twoFactor.setStore(store);
    };
    AccountsPassword.prototype.authenticate = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, password, code, foundUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        user = params.user, password = params.password, code = params.code;
                        if (!user || !password) {
                            throw new server_1.AccountsJsError(this.options.errors.unrecognizedOptionsForLogin, errors_1.AuthenticateErrors.UnrecognizedOptionsForLogin);
                        }
                        if ((!lodash_1.isString(user) && !lodash_1.isPlainObject(user)) || !lodash_1.isString(password)) {
                            throw new server_1.AccountsJsError(this.options.errors.matchFailed, errors_1.AuthenticateErrors.MatchFailed);
                        }
                        return [4 /*yield*/, this.passwordAuthenticator(user, password)];
                    case 1:
                        foundUser = _a.sent();
                        if (!two_factor_1.getUserTwoFactorService(foundUser)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.twoFactor.authenticate(foundUser, code)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, foundUser];
                }
            });
        });
    };
    /**
     * @description Find a user by one of his emails.
     * @param {string} email - User email.
     * @returns {Promise<Object>} - Return a user or null if not found.
     */
    AccountsPassword.prototype.findUserByEmail = function (email) {
        return this.db.findUserByEmail(email);
    };
    /**
     * @description Find a user by his username.
     * @param {string} username - User username.
     * @returns {Promise<Object>} - Return a user or null if not found.
     */
    AccountsPassword.prototype.findUserByUsername = function (username) {
        return this.db.findUserByUsername(username);
    };
    /**
     * @description Add an email address for a user.
     * It will trigger the `validateEmail` option and throw if email is invalid.
     * Use this instead of directly updating the database.
     * @param {string} userId - User id.
     * @param {string} newEmail - A new email address for the user.
     * @param {boolean} [verified] - Whether the new email address should be marked as verified.
     * Defaults to false.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link AddEmailErrors}
     */
    AccountsPassword.prototype.addEmail = function (userId, newEmail, verified) {
        if (verified === void 0) { verified = false; }
        if (!this.options.validateEmail(newEmail)) {
            throw new server_1.AccountsJsError(this.options.errors.invalidEmail, errors_1.AddEmailErrors.InvalidEmail);
        }
        return this.db.addEmail(userId, newEmail, verified);
    };
    /**
     * @description Remove an email address for a user.
     * Use this instead of directly updating the database.
     * @param {string} userId - User id.
     * @param {string} email - The email address to remove.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsPassword.prototype.removeEmail = function (userId, email) {
        return this.db.removeEmail(userId, email);
    };
    /**
     * @description Marks the user's email address as verified.
     * @param {string} token - The token retrieved from the verification URL.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link VerifyEmailErrors}
     */
    AccountsPassword.prototype.verifyEmail = function (token) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, verificationTokens, tokenRecord, emailRecord;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!token || !lodash_1.isString(token)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidToken, errors_1.VerifyEmailErrors.InvalidToken);
                        }
                        return [4 /*yield*/, this.db.findUserByEmailVerificationToken(token)];
                    case 1:
                        user = _a.sent();
                        if (!user) {
                            throw new server_1.AccountsJsError(this.options.errors.verifyEmailLinkExpired, errors_1.VerifyEmailErrors.VerifyEmailLinkExpired);
                        }
                        verificationTokens = utils_1.getUserVerificationTokens(user);
                        tokenRecord = lodash_1.find(verificationTokens, function (t) { return t.token === token; });
                        if (!tokenRecord || this.isTokenExpired(tokenRecord, this.options.verifyEmailTokenExpiration)) {
                            throw new server_1.AccountsJsError(this.options.errors.verifyEmailLinkExpired, errors_1.VerifyEmailErrors.VerifyEmailLinkExpired);
                        }
                        emailRecord = lodash_1.find(user.emails, function (e) { return e.address === tokenRecord.address; });
                        if (!emailRecord) {
                            throw new server_1.AccountsJsError(this.options.errors.verifyEmailLinkUnknownAddress, errors_1.VerifyEmailErrors.VerifyEmailLinkUnknownAddress);
                        }
                        return [4 /*yield*/, this.db.verifyEmail(user.id, emailRecord.address)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Reset the password for a user using a token received in email.
     * It will trigger the `validatePassword` option and throw if password is invalid.
     * @param {string} token - The token retrieved from the reset password URL.
     * @param {string} newPassword - A new password for the user.
     * @returns {Promise<LoginResult | null>} - If `returnTokensAfterResetPassword` option is true return the session tokens and user object, otherwise return null.
     * @throws {@link ResetPasswordErrors}
     */
    AccountsPassword.prototype.resetPassword = function (token, newPassword, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, resetTokens, resetTokenRecord, emails, password, address, passwordChangedMail;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!token || !lodash_1.isString(token)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidToken, errors_1.ResetPasswordErrors.InvalidToken);
                        }
                        if (!this.options.validatePassword(newPassword)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidNewPassword, errors_1.ResetPasswordErrors.InvalidNewPassword);
                        }
                        return [4 /*yield*/, this.db.findUserByResetPasswordToken(token)];
                    case 1:
                        user = _a.sent();
                        if (!user) {
                            throw new server_1.AccountsJsError(this.options.errors.resetPasswordLinkExpired, errors_1.ResetPasswordErrors.ResetPasswordLinkExpired);
                        }
                        resetTokens = utils_1.getUserResetTokens(user);
                        resetTokenRecord = lodash_1.find(resetTokens, function (t) { return t.token === token; });
                        if (!resetTokenRecord ||
                            this.isTokenExpired(resetTokenRecord, resetTokenRecord.reason === 'enroll'
                                ? this.options.passwordEnrollTokenExpiration
                                : this.options.passwordResetTokenExpiration)) {
                            throw new server_1.AccountsJsError(this.options.errors.resetPasswordLinkExpired, errors_1.ResetPasswordErrors.ResetPasswordLinkExpired);
                        }
                        emails = user.emails || [];
                        if (!lodash_1.includes(emails.map(function (email) { return email.address; }), resetTokenRecord.address)) {
                            throw new server_1.AccountsJsError(this.options.errors.resetPasswordLinkUnknownAddress, errors_1.ResetPasswordErrors.ResetPasswordLinkUnknownAddress);
                        }
                        return [4 /*yield*/, this.options.hashPassword(newPassword)];
                    case 2:
                        password = _a.sent();
                        // Change the user password and remove the old token
                        return [4 /*yield*/, this.db.setResetPassword(user.id, resetTokenRecord.address, password, token)];
                    case 3:
                        // Change the user password and remove the old token
                        _a.sent();
                        this.server.getHooks().emit(server_1.ServerHooks.ResetPasswordSuccess, user);
                        if (!(resetTokenRecord.reason === 'enroll')) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.db.verifyEmail(user.id, resetTokenRecord.address)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (!this.options.invalidateAllSessionsAfterPasswordReset) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.db.invalidateAllSessions(user.id)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!this.options.notifyUserAfterPasswordChanged) return [3 /*break*/, 9];
                        address = user.emails && user.emails[0].address;
                        if (!address) {
                            throw new server_1.AccountsJsError(this.options.errors.noEmailSet, errors_1.ResetPasswordErrors.NoEmailSet);
                        }
                        passwordChangedMail = this.server.prepareMail(address, '', this.server.sanitizeUser(user), '', this.server.options.emailTemplates.passwordChanged, this.server.options.emailTemplates.from);
                        return [4 /*yield*/, this.server.options.sendMail(passwordChangedMail)];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9:
                        if (this.options.returnTokensAfterResetPassword) {
                            return [2 /*return*/, this.server.loginWithUser(user, infos)];
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * @description Change the password for a user.
     * @param {string} userId - User id.
     * @param {string} newPassword - A new password for the user.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsPassword.prototype.setPassword = function (userId, newPassword) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var password;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.options.hashPassword(newPassword)];
                    case 1:
                        password = _a.sent();
                        return [2 /*return*/, this.db.setPassword(userId, password)];
                }
            });
        });
    };
    /**
     * @description Change the current user's password.
     * It will trigger the `validatePassword` option and throw if password is invalid.
     * @param {string} userId - User id.
     * @param {string} oldPassword - The user's current password.
     * @param {string} newPassword - A new password for the user.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link ChangePasswordErrors}
     */
    AccountsPassword.prototype.changePassword = function (userId, oldPassword, newPassword) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, password, address, passwordChangedMail;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.options.validatePassword(newPassword)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidPassword, errors_1.ChangePasswordErrors.InvalidPassword);
                        }
                        return [4 /*yield*/, this.passwordAuthenticator({ id: userId }, oldPassword)];
                    case 1:
                        user = _a.sent();
                        return [4 /*yield*/, this.options.hashPassword(newPassword)];
                    case 2:
                        password = _a.sent();
                        return [4 /*yield*/, this.db.setPassword(userId, password)];
                    case 3:
                        _a.sent();
                        this.server.getHooks().emit(server_1.ServerHooks.ChangePasswordSuccess, user);
                        if (!this.options.invalidateAllSessionsAfterPasswordChanged) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.db.invalidateAllSessions(user.id)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (!this.options.removeAllResetPasswordTokensAfterPasswordChanged) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.db.removeAllResetPasswordTokens(user.id)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!this.options.notifyUserAfterPasswordChanged) return [3 /*break*/, 9];
                        address = user.emails && user.emails[0].address;
                        if (!address) {
                            throw new server_1.AccountsJsError(this.options.errors.noEmailSet, errors_1.ChangePasswordErrors.NoEmailSet);
                        }
                        passwordChangedMail = this.server.prepareMail(address, '', this.server.sanitizeUser(user), '', this.server.options.emailTemplates.passwordChanged, this.server.options.emailTemplates.from);
                        return [4 /*yield*/, this.server.options.sendMail(passwordChangedMail)];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Send an email with a link the user can use verify their email address.
     * @param {string} [address] - Which address of the user's to send the email to.
     * This address must be in the user's emails list.
     * Defaults to the first unverified email in the list.
     * If the address is already verified we do not send any email.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link SendVerificationEmailErrors}
     */
    AccountsPassword.prototype.sendVerificationEmail = function (address) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, emailRecord, token, resetPasswordMail;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!address || !lodash_1.isString(address)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidEmail, errors_1.SendVerificationEmailErrors.InvalidEmail);
                        }
                        return [4 /*yield*/, this.db.findUserByEmail(address)];
                    case 1:
                        user = _a.sent();
                        if (!user) {
                            // To prevent user enumeration we fail silently
                            if (this.server.options.ambiguousErrorMessages) {
                                return [2 /*return*/];
                            }
                            throw new server_1.AccountsJsError(this.options.errors.userNotFound, errors_1.SendVerificationEmailErrors.UserNotFound);
                        }
                        emailRecord = lodash_1.find(user.emails, function (email) { return email.address.toLowerCase() === address.toLocaleLowerCase(); });
                        if (!emailRecord || emailRecord.verified) {
                            return [2 /*return*/];
                        }
                        token = server_1.generateRandomToken();
                        return [4 /*yield*/, this.db.addEmailVerificationToken(user.id, address, token)];
                    case 2:
                        _a.sent();
                        resetPasswordMail = this.server.prepareMail(address, token, this.server.sanitizeUser(user), 'verify-email', this.server.options.emailTemplates.verifyEmail, this.server.options.emailTemplates.from);
                        return [4 /*yield*/, this.server.options.sendMail(resetPasswordMail)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Send an email with a link the user can use to reset their password.
     * @param {string} [address] - Which address of the user's to send the email to.
     * This address must be in the user's emails list.
     * Defaults to the first email in the list.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link SendResetPasswordEmailErrors}
     */
    AccountsPassword.prototype.sendResetPasswordEmail = function (address) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, token, resetPasswordMail;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!address || !lodash_1.isString(address)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidEmail, errors_1.SendResetPasswordEmailErrors.InvalidEmail);
                        }
                        return [4 /*yield*/, this.db.findUserByEmail(address)];
                    case 1:
                        user = _a.sent();
                        if (!user) {
                            // To prevent user enumeration we fail silently
                            if (this.server.options.ambiguousErrorMessages) {
                                return [2 /*return*/];
                            }
                            throw new server_1.AccountsJsError(this.options.errors.userNotFound, errors_1.SendResetPasswordEmailErrors.UserNotFound);
                        }
                        token = server_1.generateRandomToken();
                        return [4 /*yield*/, this.db.addResetPasswordToken(user.id, address, token, 'reset')];
                    case 2:
                        _a.sent();
                        resetPasswordMail = this.server.prepareMail(address, token, this.server.sanitizeUser(user), 'reset-password', this.server.options.emailTemplates.resetPassword, this.server.options.emailTemplates.from);
                        return [4 /*yield*/, this.server.options.sendMail(resetPasswordMail)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Send an email with a link the user can use to set their initial password.
     * The user's email will be verified after clicking on the link.
     * @param {string} [address] - Which address of the user's to send the email to.
     * This address must be in the user's emails list.
     * Defaults to the first email in the list.
     * @returns {Promise<void>} - Return a Promise.
     * @throws {@link SendEnrollmentEmailErrors}
     */
    AccountsPassword.prototype.sendEnrollmentEmail = function (address) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, token, enrollmentMail;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!address || !lodash_1.isString(address)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidEmail, errors_1.SendEnrollmentEmailErrors.InvalidEmail);
                        }
                        return [4 /*yield*/, this.db.findUserByEmail(address)];
                    case 1:
                        user = _a.sent();
                        if (!user) {
                            throw new server_1.AccountsJsError(this.options.errors.userNotFound, errors_1.SendEnrollmentEmailErrors.UserNotFound);
                        }
                        token = server_1.generateRandomToken();
                        return [4 /*yield*/, this.db.addResetPasswordToken(user.id, address, token, 'enroll')];
                    case 2:
                        _a.sent();
                        enrollmentMail = this.server.prepareMail(address, token, this.server.sanitizeUser(user), 'enroll-account', this.server.options.emailTemplates.enrollAccount, this.server.options.emailTemplates.from);
                        return [4 /*yield*/, this.server.options.sendMail(enrollmentMail)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Create a new user.
     * @param user - The user object.
     * @returns Return the id of user created.
     * @throws {@link CreateUserErrors}
     */
    AccountsPassword.prototype.createUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, _c, _d, userId_1, e_1;
            var _this = this;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!user.username && !user.email) {
                            throw new server_1.AccountsJsError(this.options.errors.usernameOrEmailRequired, errors_1.CreateUserErrors.UsernameOrEmailRequired);
                        }
                        if (user.username && !this.options.validateUsername(user.username)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidUsername, errors_1.CreateUserErrors.InvalidUsername);
                        }
                        if (user.email && !this.options.validateEmail(user.email)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidEmail, errors_1.CreateUserErrors.InvalidEmail);
                        }
                        _a = user.username;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.db.findUserByUsername(user.username)];
                    case 1:
                        _a = (_e.sent());
                        _e.label = 2;
                    case 2:
                        if (_a) {
                            throw new server_1.AccountsJsError(this.options.errors.usernameAlreadyExists, errors_1.CreateUserErrors.UsernameAlreadyExists);
                        }
                        _b = user.email;
                        if (!_b) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.db.findUserByEmail(user.email)];
                    case 3:
                        _b = (_e.sent());
                        _e.label = 4;
                    case 4:
                        if (_b) {
                            throw new server_1.AccountsJsError(this.options.errors.emailAlreadyExists, errors_1.CreateUserErrors.EmailAlreadyExists);
                        }
                        if (!user.password) return [3 /*break*/, 6];
                        if (!this.options.validatePassword(user.password)) {
                            throw new server_1.AccountsJsError(this.options.errors.invalidPassword, errors_1.CreateUserErrors.InvalidPassword);
                        }
                        _c = user;
                        return [4 /*yield*/, this.options.hashPassword(user.password)];
                    case 5:
                        _c.password = _e.sent();
                        _e.label = 6;
                    case 6:
                        if (!this.options.validateNewUser) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.options.validateNewUser(user)];
                    case 7:
                        _d = _e.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        _d = lodash_1.pick(user, [
                            'username',
                            'email',
                            'password',
                        ]);
                        _e.label = 9;
                    case 9:
                        // If user does not provide the validate function only allow some fields
                        user = _d;
                        _e.label = 10;
                    case 10:
                        _e.trys.push([10, 12, , 14]);
                        return [4 /*yield*/, this.db.createUser(user)];
                    case 11:
                        userId_1 = _e.sent();
                        lodash_1.defer(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var userRecord;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (this.options.sendVerificationEmailAfterSignup && user.email)
                                            this.sendVerificationEmail(user.email);
                                        return [4 /*yield*/, this.db.findUserById(userId_1)];
                                    case 1:
                                        userRecord = (_a.sent());
                                        this.server.getHooks().emit(server_1.ServerHooks.CreateUserSuccess, userRecord);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/, userId_1];
                    case 12:
                        e_1 = _e.sent();
                        return [4 /*yield*/, this.server.getHooks().emit(server_1.ServerHooks.CreateUserError, user)];
                    case 13:
                        _e.sent();
                        throw e_1;
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    AccountsPassword.prototype.isTokenExpired = function (tokenRecord, expiryDate) {
        return Number(tokenRecord.when) + expiryDate < Date.now();
    };
    AccountsPassword.prototype.passwordAuthenticator = function (user, password) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, username, email, id, foundUser, hash, isPasswordValid;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = lodash_1.isString(user)
                            ? this.toUsernameAndEmail({ user: user })
                            : this.toUsernameAndEmail(tslib_1.__assign({}, user)), username = _a.username, email = _a.email, id = _a.id;
                        foundUser = null;
                        if (!id) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.db.findUserById(id)];
                    case 1:
                        // this._validateLoginWithField('id', user);
                        foundUser = _b.sent();
                        return [3 /*break*/, 6];
                    case 2:
                        if (!username) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.db.findUserByUsername(username)];
                    case 3:
                        // this._validateLoginWithField('username', user);
                        foundUser = _b.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        if (!email) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.db.findUserByEmail(email)];
                    case 5:
                        // this._validateLoginWithField('email', user);
                        foundUser = _b.sent();
                        _b.label = 6;
                    case 6:
                        if (!foundUser) {
                            if (this.server.options.ambiguousErrorMessages) {
                                throw new server_1.AccountsJsError(this.options.errors.invalidCredentials, errors_1.PasswordAuthenticatorErrors.InvalidCredentials);
                            }
                            else {
                                throw new server_1.AccountsJsError(this.options.errors.userNotFound, errors_1.PasswordAuthenticatorErrors.UserNotFound);
                            }
                        }
                        return [4 /*yield*/, this.db.findPasswordHash(foundUser.id)];
                    case 7:
                        hash = _b.sent();
                        if (!hash) {
                            throw new server_1.AccountsJsError(this.options.errors.noPasswordSet, errors_1.PasswordAuthenticatorErrors.NoPasswordSet);
                        }
                        return [4 /*yield*/, this.options.verifyPassword(password, hash)];
                    case 8:
                        isPasswordValid = _b.sent();
                        if (!isPasswordValid) {
                            if (this.server.options.ambiguousErrorMessages) {
                                throw new server_1.AccountsJsError(this.options.errors.invalidCredentials, errors_1.PasswordAuthenticatorErrors.InvalidCredentials);
                            }
                            else {
                                throw new server_1.AccountsJsError(this.options.errors.incorrectPassword, errors_1.PasswordAuthenticatorErrors.IncorrectPassword);
                            }
                        }
                        return [2 /*return*/, foundUser];
                }
            });
        });
    };
    /**
     * Given a username, user and/or email figure out the username and/or email.
     *
     * @param user An object containing at least `username`, `user` and/or `email`.
     * @returns An object containing `id`, `username` and `email`.
     */
    AccountsPassword.prototype.toUsernameAndEmail = function (_a) {
        var user = _a.user, username = _a.username, email = _a.email, id = _a.id;
        if (user && !username && !email) {
            if (utils_1.isEmail(user)) {
                email = user;
                username = null;
            }
            else {
                username = user;
                email = null;
            }
        }
        return { username: username, email: email, id: id };
    };
    return AccountsPassword;
}());
exports.default = AccountsPassword;
//# sourceMappingURL=accounts-password.js.map