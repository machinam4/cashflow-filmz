"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var jwt = tslib_1.__importStar(require("jsonwebtoken"));
var emittery_1 = tslib_1.__importDefault(require("emittery"));
var tokens_1 = require("./utils/tokens");
var email_1 = require("./utils/email");
var server_hooks_1 = require("./utils/server-hooks");
var accounts_error_1 = require("./utils/accounts-error");
var errors_1 = require("./errors");
var defaultOptions = {
    ambiguousErrorMessages: true,
    tokenSecret: 'secret',
    tokenConfigs: {
        accessToken: {
            expiresIn: '90m',
        },
        refreshToken: {
            expiresIn: '7d',
        },
    },
    emailTemplates: email_1.emailTemplates,
    sendMail: email_1.sendMail,
    siteUrl: 'http://localhost:3000',
    userObjectSanitizer: function (user) { return user; },
    createNewSessionTokenOnRefresh: false,
    useInternalUserObjectSanitizer: true,
};
var AccountsServer = /** @class */ (function () {
    function AccountsServer(options, services) {
        this.options = lodash_1.merge(tslib_1.__assign({}, defaultOptions), options);
        if (!this.options.db) {
            throw new Error('A database driver is required');
        }
        if (this.options.tokenSecret === defaultOptions.tokenSecret) {
            console.log("\nYou are using the default secret \"" + this.options.tokenSecret + "\" which is not secure.\nPlease change it with a strong random token.");
        }
        if (this.options.ambiguousErrorMessages && this.options.enableAutologin) {
            throw new Error("Can't enable autologin when ambiguous error messages are enabled (https://www.accountsjs.com/docs/api/server/globals#ambiguouserrormessages).\nPlease set ambiguousErrorMessages to false to be able to use autologin.");
        }
        this.services = services || {};
        this.db = this.options.db;
        // Set the db to all services
        for (var service in this.services) {
            this.services[service].setStore(this.db);
            this.services[service].server = this;
        }
        // Initialize hooks
        this.hooks = new emittery_1.default();
    }
    AccountsServer.prototype.getServices = function () {
        return this.services;
    };
    AccountsServer.prototype.getOptions = function () {
        return this.options;
    };
    AccountsServer.prototype.getHooks = function () {
        return this.hooks;
    };
    /**
     * Subscribe to an accounts-js event.
     * ```javascript
     * accountsServer.on(ServerHooks.ValidateLogin, ({ user }) => {
     *   // This hook is called every time a user try to login
     *   // You can use it to only allow users with verified email to login
     * });
     * ```
     */
    AccountsServer.prototype.on = function (eventName, callback) {
        var _this = this;
        this.hooks.on(eventName, callback);
        return function () { return _this.hooks.off(eventName, callback); };
    };
    /**
     * @description Try to authenticate the user for a given service
     * @throws {@link AuthenticateWithServiceErrors}
     */
    AccountsServer.prototype.authenticateWithService = function (serviceName, params, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hooksInfo, user, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hooksInfo = {
                            // The service name, such as “password” or “twitter”.
                            service: serviceName,
                            // The connection informations <ConnectionInformations>
                            connection: infos,
                            // Params received
                            params: params,
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        if (!this.services[serviceName]) {
                            throw new accounts_error_1.AccountsJsError("No service with the name " + serviceName + " was registered.", errors_1.AuthenticateWithServiceErrors.ServiceNotFound);
                        }
                        return [4 /*yield*/, this.services[serviceName].authenticate(params)];
                    case 2:
                        user = _a.sent();
                        hooksInfo.user = user;
                        if (!user) {
                            throw new accounts_error_1.AccountsJsError("Service " + serviceName + " was not able to authenticate user", errors_1.AuthenticateWithServiceErrors.AuthenticationFailed);
                        }
                        if (user.deactivated) {
                            throw new accounts_error_1.AccountsJsError('Your account has been deactivated', errors_1.AuthenticateWithServiceErrors.UserDeactivated);
                        }
                        this.hooks.emit(server_hooks_1.ServerHooks.AuthenticateSuccess, hooksInfo);
                        return [2 /*return*/, true];
                    case 3:
                        err_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.AuthenticateError, tslib_1.__assign(tslib_1.__assign({}, hooksInfo), { error: err_1 }));
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @throws {@link LoginWithServiceErrors}
     */
    AccountsServer.prototype.loginWithService = function (serviceName, params, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hooksInfo, user, loginResult, err_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hooksInfo = {
                            // The service name, such as “password” or “twitter”.
                            service: serviceName,
                            // The connection informations <ConnectionInformations>
                            connection: infos,
                            // Params received
                            params: params,
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!this.services[serviceName]) {
                            throw new accounts_error_1.AccountsJsError("No service with the name " + serviceName + " was registered.", errors_1.LoginWithServiceErrors.ServiceNotFound);
                        }
                        return [4 /*yield*/, this.services[serviceName].authenticate(params)];
                    case 2:
                        user = _a.sent();
                        hooksInfo.user = user;
                        if (!user) {
                            throw new accounts_error_1.AccountsJsError("Service " + serviceName + " was not able to authenticate user", errors_1.LoginWithServiceErrors.AuthenticationFailed);
                        }
                        if (user.deactivated) {
                            throw new accounts_error_1.AccountsJsError('Your account has been deactivated', errors_1.LoginWithServiceErrors.UserDeactivated);
                        }
                        // Let the user validate the login attempt
                        return [4 /*yield*/, this.hooks.emitSerial(server_hooks_1.ServerHooks.ValidateLogin, hooksInfo)];
                    case 3:
                        // Let the user validate the login attempt
                        _a.sent();
                        return [4 /*yield*/, this.loginWithUser(user, infos)];
                    case 4:
                        loginResult = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LoginSuccess, hooksInfo);
                        return [2 /*return*/, loginResult];
                    case 5:
                        err_2 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LoginError, tslib_1.__assign(tslib_1.__assign({}, hooksInfo), { error: err_2 }));
                        throw err_2;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Server use only.
     * This method creates a session without authenticating any user identity.
     * Any authentication should happen before calling this function.
     * @param {User} user - The user object.
     * @param {ConnectionInformations} infos - User's connection informations.
     * @returns {Promise<LoginResult>} - Session tokens and user object.
     */
    AccountsServer.prototype.loginWithUser = function (user, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var token, sessionId, _a, accessToken, refreshToken;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.createSessionToken(user)];
                    case 1:
                        token = _b.sent();
                        return [4 /*yield*/, this.db.createSession(user.id, token, infos)];
                    case 2:
                        sessionId = _b.sent();
                        return [4 /*yield*/, this.createTokens({
                                token: token,
                                user: user,
                            })];
                    case 3:
                        _a = _b.sent(), accessToken = _a.accessToken, refreshToken = _a.refreshToken;
                        return [2 /*return*/, {
                                sessionId: sessionId,
                                tokens: {
                                    refreshToken: refreshToken,
                                    accessToken: accessToken,
                                },
                                user: user,
                            }];
                }
            });
        });
    };
    /**
     * @description Impersonate to another user.
     * @param {string} accessToken - User access token.
     * @param {object} impersonated - impersonated user.
     * @param {ConnectionInformations} infos - User connection informations.
     * @returns {Promise<Object>} - ImpersonationResult
     * @throws {@link LoginWithServiceErrors}
     */
    AccountsServer.prototype.impersonate = function (accessToken, impersonated, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, user, impersonatedUser, isAuthorized, token, newSessionId, impersonationTokens, impersonationResult, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 12, , 13]);
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) {
                            throw new accounts_error_1.AccountsJsError('Session is not valid for user', errors_1.ImpersonateErrors.InvalidSession);
                        }
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new accounts_error_1.AccountsJsError('User not found', errors_1.ImpersonateErrors.UserNotFound);
                        }
                        impersonatedUser = void 0;
                        if (!impersonated.userId) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.db.findUserById(impersonated.userId)];
                    case 3:
                        impersonatedUser = _a.sent();
                        return [3 /*break*/, 8];
                    case 4:
                        if (!impersonated.username) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.db.findUserByUsername(impersonated.username)];
                    case 5:
                        impersonatedUser = _a.sent();
                        return [3 /*break*/, 8];
                    case 6:
                        if (!impersonated.email) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.db.findUserByEmail(impersonated.email)];
                    case 7:
                        impersonatedUser = _a.sent();
                        _a.label = 8;
                    case 8:
                        if (!impersonatedUser) {
                            if (this.options.ambiguousErrorMessages) {
                                return [2 /*return*/, { authorized: false }];
                            }
                            throw new accounts_error_1.AccountsJsError("Impersonated user not found", errors_1.ImpersonateErrors.ImpersonatedUserNotFound);
                        }
                        if (!this.options.impersonationAuthorize) {
                            return [2 /*return*/, { authorized: false }];
                        }
                        return [4 /*yield*/, this.options.impersonationAuthorize(user, impersonatedUser)];
                    case 9:
                        isAuthorized = _a.sent();
                        if (!isAuthorized) {
                            return [2 /*return*/, { authorized: false }];
                        }
                        token = tokens_1.generateRandomToken();
                        return [4 /*yield*/, this.db.createSession(impersonatedUser.id, token, infos, {
                                impersonatorUserId: user.id,
                            })];
                    case 10:
                        newSessionId = _a.sent();
                        return [4 /*yield*/, this.createTokens({
                                token: newSessionId,
                                isImpersonated: true,
                                user: user,
                            })];
                    case 11:
                        impersonationTokens = _a.sent();
                        impersonationResult = {
                            authorized: true,
                            tokens: impersonationTokens,
                            user: this.sanitizeUser(impersonatedUser),
                        };
                        this.hooks.emit(server_hooks_1.ServerHooks.ImpersonationSuccess, {
                            user: user,
                            impersonationResult: impersonationResult,
                        });
                        return [2 /*return*/, impersonationResult];
                    case 12:
                        e_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.ImpersonationError, e_1);
                        throw e_1;
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Refresh a user token.
     * @param {string} accessToken - User access token.
     * @param {string} refreshToken - User refresh token.
     * @param {ConnectionInformations} infos - User connection informations.
     * @returns {Promise<Object>} - LoginResult.
     * @throws {@link RefreshTokensErrors}
     */
    AccountsServer.prototype.refreshTokens = function (accessToken, refreshToken, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sessionToken, decodedAccessToken, session, user, newToken, tokens, result, err_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 9, , 10]);
                        if (!lodash_1.isString(accessToken) || !lodash_1.isString(refreshToken)) {
                            throw new accounts_error_1.AccountsJsError('An accessToken and refreshToken are required', errors_1.RefreshTokensErrors.InvalidTokens);
                        }
                        sessionToken = void 0;
                        try {
                            jwt.verify(refreshToken, this.getSecretOrPublicKey());
                            decodedAccessToken = jwt.verify(accessToken, this.getSecretOrPublicKey(), {
                                ignoreExpiration: true,
                            });
                            sessionToken = decodedAccessToken.data.token;
                        }
                        catch (err) {
                            throw new accounts_error_1.AccountsJsError('Tokens are not valid', errors_1.RefreshTokensErrors.TokenVerificationFailed);
                        }
                        return [4 /*yield*/, this.db.findSessionByToken(sessionToken)];
                    case 1:
                        session = _a.sent();
                        if (!session) {
                            throw new accounts_error_1.AccountsJsError('Session not found', errors_1.RefreshTokensErrors.SessionNotFound);
                        }
                        if (!session.valid) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new accounts_error_1.AccountsJsError('User not found', errors_1.RefreshTokensErrors.UserNotFound);
                        }
                        newToken = void 0;
                        if (!this.options.createNewSessionTokenOnRefresh) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.createSessionToken(user)];
                    case 3:
                        newToken = _a.sent();
                        _a.label = 4;
                    case 4: return [4 /*yield*/, this.createTokens({ token: newToken || sessionToken, user: user })];
                    case 5:
                        tokens = _a.sent();
                        return [4 /*yield*/, this.db.updateSession(session.id, infos, newToken)];
                    case 6:
                        _a.sent();
                        result = {
                            sessionId: session.id,
                            tokens: tokens,
                            user: user,
                            infos: infos,
                        };
                        this.hooks.emit(server_hooks_1.ServerHooks.RefreshTokensSuccess, result);
                        return [2 /*return*/, result];
                    case 7: throw new accounts_error_1.AccountsJsError('Session is no longer valid', errors_1.RefreshTokensErrors.InvalidSession);
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        err_3 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.RefreshTokensError, err_3);
                        throw err_3;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Refresh a user token.
     * @param {string} token - User session token.
     * @param {boolean} isImpersonated - Should be true if impersonating another user.
     * @param {User} user - The user object.
     * @returns {Promise<Tokens>} - Return a new accessToken and refreshToken.
     */
    AccountsServer.prototype.createTokens = function (_a) {
        var token = _a.token, _b = _a.isImpersonated, isImpersonated = _b === void 0 ? false : _b, user = _a.user;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenConfigs, jwtData, accessToken, _c, _d, refreshToken;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        tokenConfigs = this.options.tokenConfigs;
                        jwtData = {
                            token: token,
                            isImpersonated: isImpersonated,
                            userId: user.id,
                        };
                        _c = tokens_1.generateAccessToken;
                        _d = {};
                        return [4 /*yield*/, this.createJwtPayload(jwtData, user)];
                    case 1:
                        accessToken = _c.apply(void 0, [(_d.payload = _e.sent(),
                                _d.secret = this.getSecretOrPrivateKey(),
                                _d.config = tokenConfigs.accessToken,
                                _d)]);
                        refreshToken = tokens_1.generateRefreshToken({
                            secret: this.getSecretOrPrivateKey(),
                            config: tokenConfigs.refreshToken,
                        });
                        return [2 /*return*/, { accessToken: accessToken, refreshToken: refreshToken }];
                }
            });
        });
    };
    /**
     * @description Logout a user and invalidate his session.
     * @param {string} accessToken - User access token.
     * @returns {Promise<void>} - Return a promise.
     * @throws {@link LogoutErrors}
     */
    AccountsServer.prototype.logout = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.db.invalidateSession(session.id)];
                    case 2:
                        _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LogoutSuccess, {
                            session: session,
                            accessToken: accessToken,
                        });
                        return [3 /*break*/, 4];
                    case 3: throw new accounts_error_1.AccountsJsError('Session is no longer valid', errors_1.LogoutErrors.InvalidSession);
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LogoutError, error_1);
                        throw error_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @throws {@link ResumeSessionErrors}
     */
    AccountsServer.prototype.resumeSession = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, user, e_2, e_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new accounts_error_1.AccountsJsError('User not found', errors_1.ResumeSessionErrors.UserNotFound);
                        }
                        if (!this.options.resumeSessionValidator) return [3 /*break*/, 6];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.options.resumeSessionValidator(user, session)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _a.sent();
                        throw new Error(e_2);
                    case 6:
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionSuccess, { user: user, accessToken: accessToken });
                        return [2 /*return*/, this.sanitizeUser(user)];
                    case 7:
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionError, new accounts_error_1.AccountsJsError('Invalid Session', errors_1.ResumeSessionErrors.InvalidSession));
                        throw new accounts_error_1.AccountsJsError('Invalid Session', errors_1.ResumeSessionErrors.InvalidSession);
                    case 8:
                        e_3 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionError, e_3);
                        throw e_3;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Find a session by his token.
     * @param {string} accessToken
     * @returns {Promise<Session>} - Return a session.
     * @throws {@link FindSessionByAccessTokenErrors}
     */
    AccountsServer.prototype.findSessionByAccessToken = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sessionToken, decodedAccessToken, session;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!lodash_1.isString(accessToken)) {
                            throw new accounts_error_1.AccountsJsError('An accessToken is required', errors_1.FindSessionByAccessTokenErrors.InvalidToken);
                        }
                        try {
                            decodedAccessToken = jwt.verify(accessToken, this.getSecretOrPublicKey());
                            sessionToken = decodedAccessToken.data.token;
                        }
                        catch (err) {
                            throw new accounts_error_1.AccountsJsError('Tokens are not valid', errors_1.FindSessionByAccessTokenErrors.TokenVerificationFailed);
                        }
                        return [4 /*yield*/, this.db.findSessionByToken(sessionToken)];
                    case 1:
                        session = _a.sent();
                        if (!session) {
                            throw new accounts_error_1.AccountsJsError('Session not found', errors_1.FindSessionByAccessTokenErrors.SessionNotFound);
                        }
                        return [2 /*return*/, session];
                }
            });
        });
    };
    /**
     * @description Find a user by his id.
     * @param {string} userId - User id.
     * @returns {Promise<Object>} - Return a user or null if not found.
     */
    AccountsServer.prototype.findUserById = function (userId) {
        return this.db.findUserById(userId);
    };
    /**
     * @description Deactivate a user, the user will not be able to login until his account is reactivated.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsServer.prototype.deactivateUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.db.setUserDeactivated(userId, true)];
            });
        });
    };
    /**
     * @description Activate a user.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsServer.prototype.activateUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.db.setUserDeactivated(userId, false)];
            });
        });
    };
    AccountsServer.prototype.prepareMail = function (to, token, user, pathFragment, emailTemplate, from) {
        if (this.options.prepareMail) {
            return this.options.prepareMail(to, token, user, pathFragment, emailTemplate, from);
        }
        return this.defaultPrepareEmail(to, token, user, pathFragment, emailTemplate, from);
    };
    AccountsServer.prototype.sanitizeUser = function (user) {
        var userObjectSanitizer = this.options.userObjectSanitizer;
        var baseUser = this.options.useInternalUserObjectSanitizer
            ? this.internalUserSanitizer(user)
            : user;
        return userObjectSanitizer(baseUser, lodash_1.omit, lodash_1.pick);
    };
    AccountsServer.prototype.internalUserSanitizer = function (user) {
        return lodash_1.omit(user, ['services']);
    };
    AccountsServer.prototype.defaultPrepareEmail = function (to, token, user, pathFragment, emailTemplate, from) {
        var tokenizedUrl = this.defaultCreateTokenizedUrl(pathFragment, token);
        return {
            from: emailTemplate.from || from,
            to: to,
            subject: emailTemplate.subject(user),
            text: emailTemplate.text(user, tokenizedUrl),
            html: emailTemplate.html && emailTemplate.html(user, tokenizedUrl),
        };
    };
    AccountsServer.prototype.defaultCreateTokenizedUrl = function (pathFragment, token) {
        var siteUrl = this.options.siteUrl;
        return siteUrl + "/" + pathFragment + "/" + token;
    };
    AccountsServer.prototype.createSessionToken = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.options.tokenCreator
                        ? this.options.tokenCreator.createToken(user)
                        : tokens_1.generateRandomToken()];
            });
        });
    };
    AccountsServer.prototype.createJwtPayload = function (data, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.options.createJwtPayload) return [3 /*break*/, 2];
                        _b = [{}];
                        return [4 /*yield*/, this.options.createJwtPayload(data, user)];
                    case 1:
                        _a = tslib_1.__assign.apply(void 0, [tslib_1.__assign.apply(void 0, _b.concat([(_c.sent())])), { data: data }]);
                        return [3 /*break*/, 3];
                    case 2:
                        _a = { data: data };
                        _c.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
    AccountsServer.prototype.getSecretOrPublicKey = function () {
        return typeof this.options.tokenSecret === 'string'
            ? this.options.tokenSecret
            : this.options.tokenSecret.publicKey;
    };
    AccountsServer.prototype.getSecretOrPrivateKey = function () {
        return typeof this.options.tokenSecret === 'string'
            ? this.options.tokenSecret
            : this.options.tokenSecret.privateKey;
    };
    return AccountsServer;
}());
exports.AccountsServer = AccountsServer;
exports.default = AccountsServer;
//# sourceMappingURL=accounts-server.js.map